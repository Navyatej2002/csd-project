# -*- coding: utf-8 -*-
"""diabetes prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tyNqBGQ2eHCWCME371ZBrBeUS4Uhr9e0
"""

!pip install lightgbm

import numpy as np
import pandas as pd
import lightgbm as lgb
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from lightgbm import LGBMClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score, recall_score
from sklearn.metrics import f1_score

"""DATA COLLECTION AND ANALYSIS USING PIMA INDIAN DIABETES DATASET

"""

# LOADING THE DATASET TO A PANDAS DATAFRAME
diabetes_dataset = pd.read_csv('/content/diabetes.csv')

# PRINTING THE FIRST 5 ROWS FROM THE DATASET
diabetes_dataset.head()

# CALCULATING THE NUMBER OF ROWS AND COLUMNS FROM THE DATASET
print("No of rows and columns = ", diabetes_dataset.shape)

# STATISTICS OF THE DATASET
diabetes_dataset.describe()

"""0 = *NON-DIABETIC*    
1 = *DIABETIC*
"""

# CALCULATING NUMBER OF DIABETIC AND NON DIABETIC PEOPLE FROM THE DATASET
diabetes_dataset['Outcome'].value_counts()

# CALCULATING THE MEAN OF BOTH OUTCOMES
diabetes_dataset.groupby('Outcome').mean()

# SEPARATING THE DATA AND LABELS
X = diabetes_dataset.drop(columns = 'Outcome', axis=1)
Y = diabetes_dataset['Outcome']

print(X)

print(Y)

"""DATA STANDARDIZATION

"""

scaler = StandardScaler()

scaler.fit(X)

standardized_data = scaler.transform(X)

print(standardized_data)

X = standardized_data
Y = diabetes_dataset['Outcome']

print(X)
print(Y)

"""NOW TRAIN_TEST_SPLIT"""

X_train, X_test, Y_train, Y_test = train_test_split(X,Y, test_size = 0.31, random_state=3)

print(X.shape, X_train.shape, X_test.shape)

"""TRAINING THE MODEL"""

model = lgb.LGBMClassifier(learning_rate=0.06,max_depth=-6,random_state=6)
model.fit(X_train,Y_train,eval_set=[(X_test,Y_test),(X_train,Y_train)],
          eval_metric='logloss')

print('Training accuracy {:.4f}'.format(model.score(X_train,Y_train)))
print('Testing accuracy {:.4f}'.format(model.score(X_test,Y_test)))

"""PREDICTION WITH INPUT DATA"""

input_data = (7,158,69,20,177,24.7,0.529,55)
input_data_as_numpy_array = np.asarray(input_data)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

std_data = scaler.transform(input_data_reshaped)
print(std_data)

y_pred_prob = model.predict_proba(X_test)[:, 1]

y_pred = model.predict(X_test)
precision = precision_score(Y_test, y_pred)
recall = recall_score(Y_test, y_pred)

print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")

f1 = f1_score(Y_test, y_pred)
print(f"F1 Score: {f1:.4f}")

fpr, tpr, thresholds = roc_curve(Y_test, y_pred_prob)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(10, 7))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()